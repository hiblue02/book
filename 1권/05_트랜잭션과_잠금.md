## 트랜잭션
### 트랜잭션
1. 트랜잭션은 하나의 논리적 작업 셋에 하나의 쿼리가 있은 두 개 이상의 쿼리가 있든 관걔없이 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT을 실행했을 때) 아무것도 적용되지 않아야(ROLLBACK 또는 트랜잭션을 Rollback시키는 오류가 발생했을 때) 함을 보장해 주는 것이다.
2. Memory 스토리지 엔진과 MyISAM 스토리지 엔진은 부분 업데이트(Partial Update) 현상이 발생한다. (일부만 커밋)
3. 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 한다.

## 락
### 글로벌 락
1. MySQL 서버 전체에 미치는 락.
2. 한 세션에서 글로벌 락을 획득하면, 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.
3. `FLUSH TABLES WITH READ LOCK` 명령으로 획득한다.
4. mysql 8.0부터는 일반적인 테이블의 변경은 허용하는 백업 락이 도입됬다. 
### 테이블 락
1. 개별테이블 단위로 설정되는 락.
2. `LOCK TALBES TALBE_NAME [READ | WRITE]`
3. 묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
4. InnoDB 테이블에도 테이블 락이 설정되지만, DDL만 영향을 미친다.
### 네임드 락
1. `GET_LOCK('mylock',2);`
2. 사용자가 지정한 문자열에 대한 락
3. 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용될 수 있다. (같은 데이터를 참조/변경하는 프로그램을 분류해 네임드락을 걸고 실행한다.)
### 메타데이터 락
1. 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다. 자동으로 획득되는 락이다.

## innoDB스토리지 엔진 락
### innoDB스토리지 엔진 락
1. 레코드 락 : 레코드를 잠그는 기능. 레코드 자체가 아니라 인덱스의 레코드를 잠근다. (프라이머리 키, 유니크 인덱스에 의한 변경작업인 경우 레코드락을 건다.)
2. 갭 락 : 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격 만을 잠근다. 레코드와 레코드사이 간격에 새로운 레코드가 생성되는 것을 제어한다.
3. 넥스트키 락 : 레코드 락 + 갭락. 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때, 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장한다.
   - 바이너리 로그 : 서버 인스턴스 변경사항을 저장하는 로그
4. 자동증가 락 : AUTO_INCREMENT 안정성을 위해 사용하는 테이블 수준 락. 트랜잭션과 관계없이 insert나 replace 문장에서 auto_increment를 가져오는 순간만 락이 걸렸다가 즉시 해제된다.
### 인덱스와 락
1. 변경해야 할 레코드의 인덱스에 모두 락을 건다.
2. update 문장을 위해 적절한 인덱스가 준비돼있지 않다면, 각 클라이언트 간의 동시성이 상당히 떨어져서 한 세션에서 update 하는 동안 다른 클라이언트는 기다려야 하는 상황이 발생한다.
3. 인덱스가 하나도 없다면, 테이블의 모든 레코드를 잠그게 된다. ㅎㄷㄷ
## MySQL 격리수준
| | Dirty Read | Non-Repeatable Read | Phantom Read |
|-|-|-|-|
| Read Uncommitted | 발생 | 발생 | 발생 |
| Read Committed | X | 발생 | 발생 |
| Repeatable Read | X | X | 발생(innoDb는 없음) |
| Serializable | X | X | X |
* mysql은 Repeatable Read를 주로 사용한다.
### Read Uncommited
1. 변경 내용이 commit이나 rollback 여부에 상관 없이 다른 트랜잭션에서 보인다.
2. 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 더티 리드라고 한다.
3. 정합성에 문제가 많은 격리수준
### Read Commited
1. 어떤 트랜잭션에서 데이터를 변경했더라도 commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
2. Dirty Read가 발생하지 않는다. Non-Repeatable Read는 발생할 수 있다. (트랜잭션 내에서 다시 조회하면 결과가 달라진다.)
### Repeatable Read
1. 언두 영역에 백업된 데이터를 이용해, 동일 트랜잭션 내에서는 동일한 결과를 보여준다.
2. 언두 영역을 사용하기 때문에 장시간 트랜잭션을 종료하지 않으면 언두 영역이 백업된 데이터로 무한정 커질 수도 있다.
3. `select for ~~ update`구문을 사용하면, insert된 건 나타나기도 한다 > phantom read. 언두 레코드에 잠금을 걸 수 없아 현재 영역의 데이터를 가져오게 되기 때문이다.
4. 일반적인 select문을 사용하면, 갭락과 넥스트키 락 덕분에 phatom read가 발생하지 않는다. 
### Serializable
1. 읽기 작업도 락을 획득하는 가장 엄격한 격리수준이다. 
   
