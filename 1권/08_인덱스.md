## 디스크 읽기 방식
### 랜덤 IO와 순차IO
- 순차IO는 데이터를 읽고 저장할 위치를 찾기 위해 디스크 헤더를 1번만 움직이지만, 랜덤IO는 여러번 움직인다.
- 일반적으로 쿼리를 튜닝하는 것은 랜덤IO를 줄여주는 것이다. (꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.)
- 인덱스 레인지 스탠은 데이터를 읽기 위해 주로 랜덤IO를 사용하며, 풀 테이블 스캔은 순차IO를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 풀 스캔을 사용하도록 유도할 때도 있다.
## 인덱스
- 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어둔다.
- 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.
- 인덱스가 많은 테이블은 당연히 insert, update, delete 문장의 처리가 느려진다, 하지만 select 문장은 매우 빠르게 처리할 수 있다.
- 인덱스를 역할로 구분해보면
  - 프라이머리 키 : 레코드를 대표하난 컬럼 값으로 만들어진 인덱스, 식별자(null을 허용하지 않고 중복을 허용하지 않는다.)
  - 보조 키(세컨더리 키) : 프라이머리 키 인덱스를 제외한 나머지 인덱스, 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 대체할 수 있다.
- 데이터 저장 방식으로 구분해보면
  - B-Tree : 가장 일반적인 인덱스 알고리즘. 컬럼 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘(?)
  - Hash : 컬럼의 값을 해시값으로 계산해서 인덱싱하는 알고리즘, 매우 빠른 겁색을 지원한다. 값을 변경해서 인덱싱하므로, 값의 일부만 검색하거나 범위 검색할 때는 사용할 수 없다.
## B-tree 인덱스
- 트리 구조 : 루트노드 > 브랜치노드 > 리프노드로 구성되어 있다.
- 리프노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
- MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면, innoDB테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.
- 인덱스 키 값이 변형이 가해진 경우에는 B-tree의 빠른 검색 기능을 사용할 수 없다.
### 인덱스 사용에 영향을 미치는 요소
- B-tree 깊이
  -  인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 갯수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하드는 것을 의미한다.
- 선택도
  - 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. 선택도가 높을 수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
- 읽어야 하는 레코드 건수
  - 옵티마이저는 인덱스를 통해 읽어야할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고, 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 (필터링)방식이 효율적이라고 판단한다.
### B-tree 인덱스를 통한 데이터 읽기
- 인덱스 레인지 스캔
  - 리프노드까지 찾아들어가 필요한 레코드의 시작지점을 찾아 순서대로 리프노드를 읽는 방식. (인덱스의 **정렬**을 사용한다.)
  - 인덱스 리프노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.
    - 이때 레코드단위로 랜덤IO가 발생하기 뚜문에 인덱스를 통해 레코드를 읽은 작업은 비용이 많이 드는 작업으로 분류된다.
  - 작업 순서
    1. 인덱스 탐색 : 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.
    2. 인덱스 스캔 : 1번에서 탐색한 위키부터 필요한 만큼의 인덱스를 차례로 쭉 읽는다.
    3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.
- 인덱스 풀 스캔
  - 인덱스를 처음부터 끝까지 모두 읽는 방식. (쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우)
  - 인덱스에 포함된 컬럼만으로 데이터를 처리할 수 있는 경우
- 루스 인덱스 스캔
  - 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 갑은 무시하고 다음으로 넘어가는 형태로 처리한다.
  - 일반적으로 Group by 또는 집합함수 Min, Max 함수를 최적화할 때 사용된다.
- 인덱스 스킵 스캔
  - 가운데 인덱스를 건너뛰고 검색할 수 있도록 해주는 기능이다.
  - 루스 인덱스 스캔이 group by에만 적용됐지만, 인덱스 스킵 스캔은 where 절에도 적용된다.
  - 단점
    - where 조건절에 조건이 없는 인덱스 선행 컬럼의 유니크한 값의 갯수가 적어야 한다. (유니크한 값의 갯수 만큼 레인지 스캔 시작지점을 검색하는 작업이 필요하다.)
    - 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 한다.
### 다중 컬럼 인덱스
- 2개 이상 컬럼으로 구성된 인덱스
- 인덱스 구성 컬럼의 순서로 정렬되기 때문에, 순서가 중요하다.
###  
