## MySQL 엔진 아키텍처
### MySQL 서버
1. MySQL 엔진
  - 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저로 구성되어 있다.
2. 스토리지 엔진
  - SQL문장을 분석, 최적화
  - 데이터 스토리이지에 데이터를 저장 / 조회
  - InnoDB, MyISAM, Memory로 구성
  - 플러그인 구조로 설계되어, 기능을 추가할 수 있다. 
3. 핸들러 API
  - 쿼리 실행기에서 스토리지 엔진으로 요청을 전달/조절하는 역할
### MySQL 스레딩 구조
1. MySQL서버는 스레드 기반으로 작동한다. 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.
  - [ ] 프로세스와 스레드의 차이는?
2. 포그라운드 스레드
  - 데이터를 MySQL의 데이터버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.
  - innoDB 테이블의 데이터 버퍼, 캐시를 처리
  - MyISAM의 데이터 버퍼, 캐시, 디스크 쓰기 작업까지 처리
3. 백그라운스 스레드
  - 주로 innoDB의 작업을 처리한다.
    - 인서트 버퍼 병합
    - 로그를 디스크로 기록
    - innoDB 버퍼풀 데이터를 디스크에 기록
    - 데이터를 버퍼로 읽어오기
    - 잠금이나 데드락 모니터링 
### 메모리 할당 및 사용구조
1. 글로벌 메모리 영역 (공유 메모리 영역)
  - 테이블 캐시, innoDB 버퍼풀, innoDB 어댑티드 해시 인덱스, innoDB 리두 로그 버퍼    
2. 로컬 메모리 영역 (스레드별 메모리 영역, 절대 공유되지 않음)
  - 정렬 버퍼, 조인버퍼, 바이너리 로그 캐시, 네트워크 버퍼
### 쿼리 실행 구조
~~~
쿼리 파서 > 전처리기 > 옵티마이저 > 쿼리실행기
~~~
1. 쿼리 파서
   - 쿼리 문장을 토큰(MySQL이 이해할 수 있는 취소단위)으로 분리해 트리 형태의 구조로 만들어내는 작업.
2. 전처리기
   - 쿼리 파서의 결과를 가지고, 쿼리 정합성을 확인한다. 
3. 옵티마이저
   - 쿼리를 저렴한 비용으로 가장 빠르게 처리할 수 있는 방법을 결정한다. DBMS의 두뇌
4. 실행엔진
   - 옵티마이저가 결정한 방법을 수행하도록 핸들러에게 작업을 요청한다.
5. 핸들러
   - 작업을 수행한다. (데이터를 디스크에 저장하고 읽어온다.)
### 쿼리 캐시 : mysql8부터는 삭제됨.
### 스레드풀
1. 내부적으로 스레드 개수를 제한해, CPU가 처리에 집중할 수 있도록 하는 기능 (서버 자원 절약)
### 트랜잭션 지원 메타데이터     
1. 테이블 구조 정보나 스토어드 프로그램 코드 관련 정보를 모두 innoDB의 테이블에 저장한다. (mysql8)
2. 스키마 변경 작업 중간에 mysql 서버가 종료되면 완전 성공 or 완전 실패로 정리된다.

## 스토리지 엔진(innoDB) 아키텍처
### Primary Key에 의한 클러스터링
1. innoDB의 모든 테이블은 프라이머리 키를 기준으로 클러스터링 되어 저장된다. (프라이머리 키 순서데로 저장된다.)
2. 실행계획에서 보조 인덱스보다 비중이 높다.
### 외래 키 지원
1. 외래키는 운영환경에서는 생성하지 않는 경우도 많다.
2. 외래키는 부모 테이블과 자식 테이블 모두 인덱스를 생성해야 하고, 데이터 변경 시 서로 데이터가 있는지 확인해 데드락이 발생할 때가 많다.
### MVCC(Multi Version Concurrency Control)
1. 레코드 레벨의 트랙잭션 관리 기능으로 하나의 레코드에 대해 여러 버전이 관리되며, 읽은 시점의 데이터를 보장해준다.
2. 언두 로그를 이용해 구현.
3. 트랜잭션 격리 수준에 따른 읽기 보장
  - READ_UNCOMMITED = **버퍼풀**이 현재 가지고 있는 변경된 데이터를 읽어서 반환
  - READ_COMMITED 이상의 격리 수준 = 변경되기 전 내용을 보관하고 있는 **언두** 영역의 데이터를 반환
### 잠금 없는 일관된 읽기
1. 읽기 작업은 잠금을 걸지 않는다.
2. 격리수준이 READ_UNCOMMITED, READ_COMMITED, REPEATABLE_READ 수준이면, 다른 트랜잭션이 변경 중(잠금)이면, 방해하지 않고 언두 로그를 읽는다.
### 자동 데드락 감지
1. 자동 데드락을 감지해 교착상태에 있는 트랜잭션을 찾아 강제종료한다. (언두 로그가 적은 것부터 종료한다.)
### 자동화된 장애 복구
1. innodb_force_recovery 시스템 설정
  - 1 SRV_FORCE_IGNORE_CORRUPT : 테이블 스페이스의 데이터나, 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 서버를 재시작한다.
  - 2 SRV_FORCE_NO_BACKGROUND : 메인 스레드 없이 서버를 시작한다. 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생할 경우 사용한다.
  - 3 SRV_FORCE_NO_TRX_UNDO : 커밋되지 않은 트랜잭션의 작업을 롤백하지 않은 상태로 서버를 재시작한다.
  - 4 SRV_FORCE_NO_IBUF_MERGE : 인서트 버퍼의 내용을 무시하고 강제로 서버를 재시작한다.
  - 5 SRV_FORCE_NO_UNDO_LOG_SCAN : 언두 로그 무시, mysql서버가 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리된다.  
  - 6 SRV_FORCE_NO_LOG_REDO : 리두 로그 무시, 데이터 파일에 기록되지 않은 데이터는 모두 무시된다.
### innoDB 버퍼풀
1. 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간이다.
2. 버퍼풀을 페이지 크기 조각으로 쪼개어, innoDB 스토리지 엔진이 데이터를 필요로 할때마다, 데이터 페이지를 읽어 각 조각에 저장한다.
  - LRU(Least Recently Used) 리스트 : 자주 읽히는 페이지를 길게 보관하기 위한 용도로 사용한다. 
  - 프리 리스트 : 버퍼풀에서 비어있는 페이지 목록, 새롭게 데이터 페이지를 읽어봐야 하는 경우 사용된다. 
  - 플러시 리스트 : 디스크로 동기화되지 않은 데이터를 가진 페이지 목록.
3. 버퍼풀과 리두로그
  - 주기적으로 리두로그와 버퍼풀의 더티페이지를 디스크로 동기화한다.
  - 버퍼풀 > 리두로그면, 더티 페이지를 리두로그 용량만큼 밖에 사용하지 못한다.
  - 버퍼풀 < 리두로그 여야 좋은 설정. 그러나 리두로그 용량이 너무 크면, 갑자기 대량의 디스크 쓰기가 발생할 수 있다.
4. 버퍼풀 플러시
  - 더티 페이지를 디스크와 동기화 / LRU리스트에서 사용빈도 낮은 페이지를 하는 삭제 기능. (백그라운드로 진행한다.)
5. 버퍼풀 상태 백업 및 복구
  - innodb_buffer_pool_dump_now : 버퍼풀 상태 백업
  - innodb_buffer_pool_load_now : 버퍼풀 복구
6. 버퍼풀 적재 내용 확인
  - information_schema.innodb_buffer_page
### Double Write Buffer
1. 변경된 페이지를 묶어서 한번에 디스크에 기록하는 버퍼
### 언두로그
1. 트랜잭션 보장 : 트랜잭션이 롤백 시 언두로그의 배업 데이터를 사용한다.
2. 격리수준 보장 : 트랙잭션 격리 수준에 맞게 언두로그의 백업 데이터를 읽어서 반환하기도 한다.
3. 최대 동시 트랙잭션 갯수 = (innoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)
4. Undo tablespace truncate : 언두 테이블 스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제로 반납하는 것. (자동 & 수동)
### 체인지 버퍼
1. 임시 메모리 공간 : innoDB는 변경해야 할 인덱스 페이지가 버퍼풀에 있으면, 바로 인덱스 업데이트를 수행하지만, 디스크로부터 읽어와서 업데이트 해야 한다면, 읽어오지 않고 임시공간에 변경사항을 저장해두고 사용자에게 결과를 반환한다.
### 리두 로그 및 로그 버퍼
1. mysql 서버가 비정상적으로 종료됐을 때, 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안정장치다.
~~~
커밋됐지만 데이터 파일에 기록되지 않은 데이터 > **리두로그**로 처리 (변경후 데이터 임시 저장 공간)
롤백됐지만 데이터 파일에 이미 기록된 되에터 > **언두로그**로 처리 (변경전 데이터 임시 저장 공간)
~~~ 
2. 리두 로그 아카이빙
3. 리두 로그 활성화 및 비활성화
  - mysql 서버에서 트랜잭션이 커밋돼도 데이터 파일은 즉시 디스크로 동기화되지 않는 반면, 리두로그(트랜잭션 로그)는 항상 디스크로 기록된다.
  - 데이터를 복구하거나, 대용량 데이터를 한 번에 적재하는 경우 리두로그를 비활성화해 시간을 단축할 수 있다.
### 어댑티드 해시 인덱스
1. innoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스 (B-tree 탐색 부하를 줄여줌)
2. "인덱스 키 값 + 데이터 페이지 주소"로 구성됨.
3. 어댑티드 해시 인덱스가 성능 향상에 도움을 주는 경우
  -  디스크의 데이터가 innoDB 버퍼 풀 크기와 비슷한 경우 (디스크 읽기가 많지 않은 경우)
  -  동등 조건 검색 (동등 비교와 IN연산자)이 많은 경우
  -  쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우
4. 어댑티드 해시 인덱스가 성능 향상에 도움이 안되는 경우
  - 디스크 읽기가 많은 경우
  - 특정 패턴의 쿼리가 많은 경우 (조인, like)
  - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
  - **테이블 삭제 또는 변경 작업**
## MyISAM 스토리지 엔진 아키텍처
### 키캐시
1. innodb의 버퍼풀과 비슷한 역할을 한다.
2. 인덱스에 대해서만 작동하고, 인덱스 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다.
### 운영체제의 캐시 및 버퍼
1. MyISAM은 테이블 데이터의 디스크 IO를 해결해줄 수 있는 버퍼링 기능이 없다. 운영체제의 캐시/버퍼링 기능으로 대체된다.
### 데이터 파일과 프라이머리 키(인덱스) 구조
1. MyISAM 테이블 레코드는 pk와 무관하게 insert되는 순서대로 데이터파일에 저장된다. (innoDB는 pk로 클러스터링 되어 저장된다.)
## MYSQL 로그파일
1. 에러 로그 파일 : 실행 도중 발생하는 에러나 경고메세지가 출력되는 로그 파일. ~경로 : my.cnf / log_error = {경로}~
2. 제너럴 쿼리 로그 파일 : mysql 서버에서 실행되는 쿼리 전체 목록
  - 파일에 저장하면 : SHOW GLOBAL VARIABLES LIKE 'general_log_file';
    - 로그 파일 분석 : ~pt-query-digest --type='genlog' general.log > parsed_general.log~   
  - 테이블에 저장하면 : general_log;
3. 슬로우 로그 파일 : 일정 시간 소요된 쿼리 목록 (튜닝 대상)
  - 파일에 저장하면 : ??
    - 로그 파일 분석 : ~pt-query-digest --type='slowlog' mysql-slow.log > parse_mysql-slog.log~
  - 테이블에 저장하면 : slow_log  
