## 개요
### 파티션을 사용하는 이유
- 데이터와 인텍스를 조각화해서 물리적 메모를 효율적으로 사용할 수 있게 만들어준다. (단일 파티션 insert, update)
- 활발하게 사용되는 데이터(워킹셋)과 아닌 테이블을 분리 
- 데이터 물리적 저장소 분리: 파티션을 통해 파일의 크기를 조절, 파일의 저장 위치를 다르게 지정할 수 있다. (mysql에선 파티션 단위로 인덱스를 생성하거나, 다른 인덱스를 만드는 것은 불가능하다.)
- 이력 데이터 관리: 파티션을 삭제,추가하는 것으로 불필요한 데이터 삭제 작업을 편하게 할 수 있다.
### 파티션 내부 처리
#### 파티션 테이블 검색
SQL이 수행되기 위해 파티션 테이블을 검색할 때 성능에 크게 영향을 미치는 조건은 다음과 같다. 
1. where 걸의 조건으로 검색해야 할 파티션을 선택할 수 있는가?
2. WHERE 절의 조건이 인덱스를 효율적으로 사용(인덱스 레인지 스캔)할 수 있는가?
#### 파티션 테이블의 인덱스 스캔과 정렬
mysql의 파티션 테이블에서 인덱스는 전부 로컬 인덱스에 해당한다. 
파티션 테이블에서 인덱스 스캔을 통해 레코드를 읽을 때 mysql서버가 별도의 정렬 작업을 수행하지 않는다. 
하지만 우선순위 큐에 임시로 저장하고, 인덱스 정렬 순서데로 데이터를 보여준다.
#### 파티션 프루닝
최적화 단계에서 필요한 파이션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 거을 파티션 프루닝이라고 한다. 
## 주의사항
- 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 칼럼을 포함해야 한다.
- 파티션마다 데이터 파일을 가지기 때문에 파티션 테이블은 한번에 파티션 갯수 * 2~3개의 파일을 오픈한다. 파티션이 많은 테이블이면 한번에 열 수 있는 데이터 파일 갯수인 `open_files_limit`을 적절하게 설정해야 한다.
## 파티션의 종류
### 레인지 파티션 
파티션 키의 연속된 범위로 파티션을 정의하는 방법. 가장 일반적
기존 파티션의 분리와 병합은 reorganize를 사용한다. 
### 리스트 파티션
파티션 키값 하나하나를 리스트로 나열한다. 
MAXVALUE를 지정할 수 없다. 
- 파티션 키 값이 코드값이나 카테고리와 같이 고정적일 때
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
- 파티션 키 값을 기준으로 레코드 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때
### 해시 파티션
- 해시 함수로 레코드가 저장될 파티션을 결정하는 방법. 해시 함수 결과를 파티션 갯수로 나눈 나머지로 패티션을 결정한다.
- 파티션 키는 항상 정수 타입이어야 한다.
- 레인지/리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용빈도를 보이지만, 테이블이 너무 커서 파티션을 적용해야 할 때
- 해시 파티션은 분할/병합 할 수 없다. 특정 파티션을 삭제할 수 없다. 파티션 갯수를 줄이는 것만 가능한다. `COALESCE PARTITION`을 사용한다.
### 키 파티션 
- 대부분의 데이터 ㅌ입에 대해 파티션 키를 적용할 수 있다.
- 프라이머리 키나 유니크 키를 구성하는 칼럼 중 일부만으로도 파티션할 수 있다.
- 유니크 키를 파티션 키로 사용할 때, 해당 유니크 키는 반드시 Not Null 이어야 한다.
- 해시 파티션에 비해 파티션 간의 레코드를 더 균등하게 분할할 수 있다.
## 파티션 테이블의 쿼리 성능
- 10개의 파티션이 모두 비슷하게 사용된다면, 성능 향상보다 오버헤드만 심해지는 결과를 가져올 수 있다.

