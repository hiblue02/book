## 개요
- Source 서버: 원본 데이터를 가진 서버
- Replica 서버: 복제된 데이터를 가지는 서버 
- 복제 서버를 구축하는 목적
  - scale out: 동일한 데이터를 가진 DB 서버를 한 대 이상 복제해 트래픽을 분산
  - 데이터 백업: 동일한 서버에서 데이터 백업이 진행되면, DBMS가 서버 자원을 공유하기 때문에 운영 환경에 영향을 준다. 
  - 데이터 분석
  - 데이터의 지리적 분산: 
## 복제 아키텍처
1. Source 서버에서 바이너리 로그 생성(변경사항) 
2. 바이너리 로그를 레플리카 서버로 전송
3. 레플리카 서버에서 릴레이 로그 생성 
4. 레플리카 서버에서 릴레이 로그를 읽어 변경사항 반영

## 복제 타입
소스 서버의 바이너리 로그에 기록된 변경내역들을 식별하는 방식에 따라 `바이너리 로그 파일 위치 기반 복제`와 `글로벌 트랜잭션ID 기반 복제`로 나뉜다. 
### 바이너리 로그 파일 위치 기반 복제
- 바이너리 로그파일명과 파일 내에서의 위치(Offset 또는 Position)로 이벤트를 식별한다.
- 로그 파일명과 위치값으로 구성된 식별값은 소스 서버에서만 유효하다. 복제 서버에선 식별값이 달라진다. > **GTID**
### 글로벌 트랜잭션 아이디 기반 복제
- GTID: Global Transaction Identifier, 전체 MySQL 서버에서 고유하도록 이벤트에서 부여된 식별값
## 복제 데이터 포맷
### Statement 기반
- 실행된 SQL문이 그대로 바이너리 로그에 저장되는 형태 
- UUID()와 같은 함수를 사용하거나, NOWAIT / SKIP LOCKED 옵션 등 비확정적 쿼리가 실행되는 경우, 소스 서버와 레플리카 서버 간 데이터 일관성을 해칠 수 있다. 
- 트랜잭션 격리수준이 Repeatable-Read 여야 한다. 이 수준 이하의 방식ㅇ에서는 하나의 트랜잭션 내에서도 시점마다 데이터 스냅숏이 달라지기 때문이다. 
### Row 기반 바이너리 로그 
- 변경된 값 자체가 바이너리 로그에 저장되는 형태
- 비확정적 쿼리를 사용해도 안정적으로 복제할 수 있다. 
- 로그 파일 크기가 매우 클 수 있다. 
- 레플리카 서버에선 어떤 쿼리로 데이터가 넘어왔는지 확인할 수 없다.(mysqlbinlog 프로그램으로 변환해야 한다.)
- 모든 트랜잭션 격리수준에서 사용할 수 있다. 
- DCL과 DDL은 Statement 형태로 저장된다. 
### Mixed 
- 기본적으로 Statement 포맷을 사용하고, 실행된 쿼리와 스토리지 인젠의 종류에 따라 필요시 자동으로 Row 포맷으로 전환해서 로그에 기록한다. 
## 복제 동기화 방식
### 비동기 복제
- 소스 서버에서 레플리카 서버에 변경 이벤트가 잘 전달되어 적용됐는지 확인하지 않는다. 
- 트랜잭션이 누락될 수 있다. 
- 빠르다
### 반동기 복제
- 레플리카 서버가 변경 이벤트를 릴레이 로그에 기록 후 응답을 보낸다. 소스 서버는 응답을 받으면 트랜잭션을 commit 시키고 클라이언트에 결과를 반환한다. 
- 레플리카 서버에 전송됐음은 보장하나, 적용은 보장하지 않는다. 
## 복제 토폴로지
### 싱글 레플리카
- 소스 서버에 레플리카 서버 1대만 연결되어 있는 복제 형태 
- 레플리카 서버는 장애 상황에 사용한다. 배치나 어드민 툴에서 사용하기도 한다. 
### 멀티 레플리카 
- 하나의 소스 서버에 레플리카 2개 이상 구성 
- 읽기 요청을 처리하는 전용 레플리카 구성
### 체인 
- 1:M:M 구조
- 중간 계층의 레플리카 서버이면서 동시에 서버 역할을 하는 서버에서 바이너리 로그와 log_slave_updates 설정이 활성화 되어 있어야 한다. 
- 장애 처리 복잡도가 높아진다. 
### 듀얼 소스
- 두 개의 mysql 서버가 서로 소스 서버이자 레플리카 서버로 구성돼 있는 형태 
- ACTIVE-PASSIVE: 한 쪽은 읽기만 하는 형태, 예비 서버에서 바로 쓰기 작업이 가능한 상태로 장애 시 전환이 빠르다. 
- ACTIVE-ACTIVE: 양 쪽에서 쓰고 읽는 형태, 지리적으로 먼곳에서 유입되는 쓰기 요청을 빠르게 처리하기 위해 사용한다. 동기 지연이 있을 수 있다. 
  - 동일한 데이터를 각 서버에서 변경할 때 주의
  - auto-increment를 사용할 때 주의: 어플리케이션에서 글로벌하게 값을 생성해서 사용하거나, 서버별로 auto_increment_offset 시스템 변수를 적절하게 설정해야 한다.
### 멀티 소스 
- 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태 (샤딩)
## 고급 설정 
### 지연된 복제
- 의도적으로 레플리카 서버의 복제를 지연시키는 기능 
- CHANGE REPLICATION SOURCE TO에 SOURCE_DELAY 기능을 추가해 사용할 수 있다. 
### 멀티 스레드 복제 
- 코디네이터 스레드가 이벤트를 읽어 설정된 방식에 따라 스케줄링 해 워커 스레드에 할당한다. 
### 크래시 세이프 복제
- mysql이 비정상 종료 후 재구동 됐을 때 복제가 원활하게 될 수 있도록 하는 기능
- relay_log_recovery 옵션을 활성화하면 MySQL 서버는 스레드 포지션을 SQL 스레드가 마지막으로 실행했던 포지션으로 초기화하고 새로운 릴레이 로그를 생성해 SQL 스레드가 읽어야할 릴레이 로그 포지션 위치를 초기화한다. 이 작업으로 비정상적으로 종료되기 전 마지막 트랜잭션 이후로 다시 정상적인 복제를 할 수 있다. 
- 그러나 운영체제 비정상 종료에는 보장될 수 없다.
### 필터링된 복제
- 소스 서버의 특정 이벤트만 레플리카 서버에 적용될 수 있도록 하는 기능
- binog-do-db 바이너리 로그에 저장할 데이터베이스명
- binlog-ignore-db 바이너리 로그에 저장하지 않을 데이터베이스명
