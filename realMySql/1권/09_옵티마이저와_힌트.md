## 개요
### 쿼리 실행 절차
1. SQL 파서가 문장을 잘개 쪼개, MySQL 서버가 이해할 수 있는 수준으로 분리(파스트리)한다. (mysql 엔진)
2. SQL의 파싱정보를 확인하며서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다. (mysql 엔진)
3. 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.(mysql 엔진, 스토리지 엔진)
## 기본 데이터 처리
### 풀 테이블 스캔과 풀 인덱스 스캔
1. innoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 Read ahead 작업이 자동으로 시작된다.
  - Read ahead : 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 미리 디스크에서 읽어 innoDB 버퍼풀에 가져다 두는 것을 의미한다.
2. 풀 테이블 스캔, 풀 인덱스 스캔이 실행되면 처음에는 포그라운드 스레드가 페이지를 읽지만, 특정 시점부터는 백그라운드 스레드로 넘긴다. (Read ahead 시작)
  - `innodb_read_ahead_threshold` 시스템 변수로 innoDB 스토리지 엔진이 언제 Read ahead를 시작할지 임계값을 설정할 수 있다.
### 병렬처리
1. `SET SESSION innodb_parallel_read_threads=1` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경할 수 있다.
### ORDER BY
1. 인덱스를 이용하는 방법과 쿼리가 실행될 때 `FileSort`라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.
   | 방법 | 장점 | 단점 |
   | :-: | ----- | ----- |
   | 인덱스 | INSERT, UPDATE, DELETE 쿼리가 실행될 때, 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다. | INSERT, UPDATE, DELETE 작업 시 부가적인 인텍스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 많이 필요하다. 인덱스의 개수가 늘어날수록 innoDB 버퍼 풀을 위한 메모리가 많이 필요하다.|
   | Filesort | 쓰기 작업이 빠르다. | 정렬 작업이 쿼리 실행 시 처리되므로, 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.|
2. 소트 버퍼
  - 정렬을 수행하는 별도의 메모리 공간
  - 정렬해야할 레코드 건수가 소트 버퍼 공간보다 크다면, 소트 버퍼에서 정렬을 수행하고 결과를 임시 디스크에 기록한다. 이를 반복하면서 임시 디스크의 데이터를 병합(multi-merge)한다.
3. 정렬 알고리즘
  - 투 패스(Two-pass) : 정렬 기준 칼럼, rowId만 소트 버퍼에 담아 정렬
  - 싱글 패스(Single-pass) : 레코드 전체를 소트 버퍼에 담아 정렬, 레코드의 칼럼을 고정 사이즈로 메모리에 저장
  - 싱글 패스(Single-pass) + : 레코드 전체를 소트 버퍼에 담아 정렬, 레코드 칼럼을 가변 사이즈로 메모리에 저장
  - 싱글 패스 장식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이다.
4. 정렬 처리 방법
  | 정렬 처리 방법 | 실행 계획 Extra 칼럼 내용 |
  | ----------- | -------------------- |
  | 인덱스 | - |
  | 조인에서 드라이빙 테이블만 정렬 | "Using FileSort" |
  | 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | "Using temporary; Using filesort"|
  
