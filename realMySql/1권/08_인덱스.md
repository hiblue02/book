## 디스크 읽기 방식
### 랜덤 IO와 순차IO
- 순차IO는 데이터를 읽고 저장할 위치를 찾기 위해 디스크 헤더를 1번만 움직이지만, 랜덤IO는 여러번 움직인다.
- 일반적으로 쿼리를 튜닝하는 것은 랜덤IO를 줄여주는 것이다. (꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.)
- 인덱스 레인지 스탠은 데이터를 읽기 위해 주로 랜덤IO를 사용하며, 풀 테이블 스캔은 순차IO를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 풀 스캔을 사용하도록 유도할 때도 있다.
## 인덱스
- 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어둔다.
- 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.
- 인덱스가 많은 테이블은 당연히 insert, update, delete 문장의 처리가 느려진다, 하지만 select 문장은 매우 빠르게 처리할 수 있다.
- 인덱스를 역할로 구분해보면
  - 프라이머리 키 : 레코드를 대표하난 컬럼 값으로 만들어진 인덱스, 식별자(null을 허용하지 않고 중복을 허용하지 않는다.)
  - 보조 키(세컨더리 키) : 프라이머리 키 인덱스를 제외한 나머지 인덱스, 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 대체할 수 있다.
- 데이터 저장 방식으로 구분해보면
  - B-Tree : 가장 일반적인 인덱스 알고리즘. 컬럼 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘(?)
  - Hash : 컬럼의 값을 해시값으로 계산해서 인덱싱하는 알고리즘, 매우 빠른 겁색을 지원한다. 값을 변경해서 인덱싱하므로, 값의 일부만 검색하거나 범위 검색할 때는 사용할 수 없다.
## B-tree 인덱스
- 트리 구조 : 루트노드 > 브랜치노드 > 리프노드로 구성되어 있다.
- 리프노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
- MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면, innoDB테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.
- 인덱스 키 값이 변형이 가해진 경우에는 B-tree의 빠른 검색 기능을 사용할 수 없다.
### 인덱스 사용에 영향을 미치는 요소
- B-tree 깊이
  -  인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 갯수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하드는 것을 의미한다.
- 선택도
  - 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. 선택도가 높을 수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
- 읽어야 하는 레코드 건수
  - 옵티마이저는 인덱스를 통해 읽어야할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고, 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 (필터링)방식이 효율적이라고 판단한다.
### B-tree 인덱스를 통한 데이터 읽기
- 인덱스 레인지 스캔
  - 리프노드까지 찾아들어가 필요한 레코드의 시작지점을 찾아 순서대로 리프노드를 읽는 방식. (인덱스의 **정렬**을 사용한다.)
  - 인덱스 리프노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.
    - 이때 레코드단위로 랜덤IO가 발생하기 때문에 인덱스를 통해 레코드를 읽은 작업은 비용이 많이 드는 작업으로 분류된다.
  - 작업 순서
    1. 인덱스 탐색 : 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.
    2. 인덱스 스캔 : 1번에서 탐색한 위키부터 필요한 만큼의 인덱스를 차례로 쭉 읽는다.
    3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.
- 인덱스 풀 스캔
  - 인덱스를 처음부터 끝까지 모두 읽는 방식. (쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우)
  - 인덱스에 포함된 컬럼만으로 데이터를 처리할 수 있는 경우
- 루스 인덱스 스캔
  - 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 갑은 무시하고 다음으로 넘어가는 형태로 처리한다.
  - 일반적으로 Group by 또는 집합함수 Min, Max 함수를 최적화할 때 사용된다.
- 인덱스 스킵 스캔
  - 가운데 인덱스를 건너뛰고 검색할 수 있도록 해주는 기능이다.
  - 루스 인덱스 스캔이 group by에만 적용됐지만, 인덱스 스킵 스캔은 where 절에도 적용된다.
  - 단점
    - where 조건절에 조건이 없는 인덱스 선행 컬럼의 유니크한 값의 갯수가 적어야 한다. (유니크한 값의 갯수 만큼 레인지 스캔 시작지점을 검색하는 작업이 필요하다.)
    - 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 한다.
### 다중 컬럼 인덱스
- 2개 이상 컬럼으로 구성된 인덱스
- 인덱스 구성 컬럼의 순서로 정렬되기 때문에, 순서가 중요하다.
### 인덱스 정렬과 스캔
- 인덱스를 생성하는 시점에 인텍스를 구성하는 각 컬럼의 정렬을 오름차순 또는 내림차순으로 설정할 수 있다.
  - `CREATE INDEX ix_teamname_userscore ON employees(team_name ASC, user_score DESC)` 
- 인덱스 역순 스캔이 정순 스캔보다 느리다.
  - 페이지 잠금이 인덱스 정ㅇ순 스캔에 적합한 구조.
  - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조.
### b-tree 인덱스의 가용성과 효율성
- 작업 범위 결정 조건이 많을수록 쿼리 성능이 높아지지만, 필터링 조건은 많아도 성능을 높이진 못한다. 
  - 작업 범위 결정 조건 : 작업 범위를 결정하는 조건
  - 필터링 조건 : 작업 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건
- 선행 조건이 쿼리 조건절에 포함되어야 한다. (인덱스 컬럼 순서)
- B-tree 인덱스를 사용할 수 없는 경우
  - NOT-EQUAL로 비교된 경우("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
  - LIKE '%??'(앞부분이 아닌 뒷 부분 일치) 형태로 문자열 패턴이 비교된 경우
  - 스토어드 함수나 다른 연산자로 인텍스 칼럼이 변형된 후 비교된 경우(ex)substring
  - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
  - 데이터 타입이 다른 경우
  - 문자열 데이터 타입의 콜레이션(문자열처리방법)이 다른 경우
- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
  - 인덱스 선두 컬럼에 대한 조건이 없는 경우
  - 인덱스 선두 컬럼의 비교조건이 인덱스 사용 불가 조건인 경우
## R-Tree 인덱스
- 2차원 데이터를 인덱싱하고 검색하는 목적의 인덱스 (ex) GPS
## 전문 검색 인덱스
- 문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘
  - 어근 분석 알고리즘 : 형태소 분석 후 인덱싱
  - n-gram 알고리즘 : 본문을 무조건 몇 글자씩 잘라서 인덱싱
## 함수 기반 인덱스
- 칼럼의 값을 변형해서 만들어진 값에 대해 구축된 인덱스
- 가상 칼럼을 이용한 인덱스
  - 가상 칼럼을 추가하고, 그 가상 칼럼에 인덱스를 생성한다. (가상 칼럼 옵션 virtual, stored은 상관 없다.)
  ~~~sql
  alter table user
    add full_nmae varchar(30) as (concat(first_name, ' ', last_name)) virtual.
    add index ix_fullname(fullname);
  ~~~
- 함수를 이용한 인덱스
  - 테이블 구조를 변경하지 않고, 함수를 직접 사용하는 인덱스를 생성할 수 있다.
  - 인덱스를 활용하려면, 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 한다.
  ~~~sql
  alter table user
    add index ix_fullname((concat(first_name,' ',last_name)));
  ~~~
## 멀티 벨류 인덱스
- 인덱스 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다.
  - https://dev.mysql.com/doc/refman/8.0/en/create-index.html#create-index-multi-valued
  - `ALTER TABLE customers ADD INDEX zips( (CAST(custinfo->'$.zipcode' AS UNSIGNED ARRAY)) );`
- 멀티 벨류 인덱스를 활용하기 위해서는 아래 함수를 이용해서 검색해야 한다.
  - a MEMBER OF(~) : ~값에 a를 포함 
  ~~~sql
  mysql> SELECT * FROM customers
    ->     WHERE 94507 MEMBER OF(custinfo->'$.zipcode');
  ~~~
  - JSON_CONTAINS(~, a) : ~값에 a를 포함 (IN)
  ~~~sql
  mysql> SELECT * FROM customers
    ->     WHERE JSON_CONTAINS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));
  ~~~
  - JSON_OVERLAPS(~, a) : ~값에 a중 하나를 포함
  ~~~sql
  mysql> SELECT * FROM customers
    ->     WHERE JSON_OVERLAPS(custinfo->'$.zipcode', CAST('[94507,94582]' AS JSON));
  ~~~
## 클러스터링 인덱스
- **프라이머리 키**에 값이 비슷한 레코드끼리 묶어서 저장한 인덱스(프라이머리 키에 따라 물리적 저장 위치가 결정된다.)
  - 프라이머리 키가 없으면 첫번째 유니크 인덱스를 클러스터링 키로 선택한다.
  - innoDB에서만 지원한다. 
- innoDB 테이블(클러스터링) 테이블의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키를 저장한다.
  - rowid를 저장하면, 클러스터링 키 값이 바뀔때마다 모든 인덱스를 바꿔야한다.
- 장점
  - 빠르다.
  - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 갖고 있기 때문에, 인덱스만으로 처리될 수 있는 경우가 많다.
- 단점
  - 클러스터링 키가 크면, 전체적으로 인덱스가 커진다.(테이블의 모든 세컨더리 인덱스가 프라이머리 키를 갖고 있음.)
  - 세컨더리 인덱스로 검색하면, 프라이머리 키로 한번 더 검색하기 때문에 성능이 느리다.
  - insert 속도가 느리다. (프라이머리 키를 수정하러면 레코드를 delete>insert하기 때문에 느리다.)
- 주의사항
  - 클러스터링 키가 크면, 전체적으로 인덱스가 커진다.
  - 프라이머리 키는 auto-increment보다는 업무적인 칼럼으로 생성하는 것이 좋다. (검색에서 빈번하게 사용하는 경우)
  - 세컨더리 인덱스가 필요하고, 프라이머리 키의 크기도 길다면 auto_increment 칼럼을 프라이머리 키로 설정하자. 
  - 프라이머리 키를 반드시 생성해야 한다.
## 유니크 인덱스
- 유니크 인덱스에서도 null이 저장될 수 있는데, null은 특정 값이 아니므로 2개 이상 저장될 수 있다.
- 프라이머리키는 유니크 인덱스가 자동으로 생성된다.
## 외래키
- innoDB에서만 사용할 수 있으면, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까시 생성된다.
- 테이블 변경(쓰기 잠금)이 발생하는 경우에만 잠금(경합)이 발생한다.
- 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금대기를 발생시키지 않는다.)
