### 람다 식과 멤버 참조
- 람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다. 코틀린의 람다 식은 항상 중괄호로 둘러싸여 있다. `->`가 인자 목록과 람다 본문을 구분해준다.
- ```kotlin
  {x:Int, y:Int -> x + y}
  ```
- `run`: 코드의 일부분을 불록으로 둘러싸 실행할 필요가 있다면 run을 사용한다. run은 인자로 받은 람다를 실행해주는 라이브러리다.
- `it`: 디폴트 파라미터, 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it을 바로 쓸 수 있다.
- `변수 포획 capture`: 코틀린 람다 안에선 파이널 변수가 아닌 변수에 접근할 수 있다. 또 람다 안에서 바깥 변수를 변경해도 된다.
- `멤버 참조`: 람다로 넘기려는 함수가 이미 선언된 경우 사용한다. `클래스::함수` 형태로 사용한다.
    - 바운드 멤버 참조: `인스턴스명::함수` 형태로 이미 생성된 인스턴스의 함수를 람다로 넘겨줄 수 있다.
### 컬렉션 함수형 API
- `filter`: 컬렉션에서 원치 않는 원소를 제거한다.
- `map`: 컬렉션 원소의 값을 변환한다.
    > map(자료구조)는 키와 값을 처리하는 함수가 따로 존재한다. filterKeys와 mapKeys는 키를 걸러내거나 변환하고, filterValues와 mapValues는 값을 걸러내거나 변환한다.
- `all`: 모든 원소가 조건을 만족하는지 확인한다.
- `any`: 조건을 만족하는 원소가 하나라도 있는지 확인한다. (!any와 그 조건의 부정에 대해 all을 수행한 결과는 같다)
- `count`: 조건을 만족하는 원소의 갯수를 확인한다.
- `find`: 조건을 만족하는 원소를 하나 찾고 싶을 때 사용한다. (술어.. predicate인가..) = firstOrNull 만족하는 원소가 없으면 null이 나온다.
- `groupBy`: 리스트를 여러 그룹의 Map으로 바꾼다.(조건을 기준으로 묶는다.)
- `flatMap`, `flatten`: 중첩된 컬렉션의 원소를 분해해 컬랙션 하나로 바꾼다.
    - 리스트의 리스트가 있는데, 모두 중첩된 리스트의 원소를 한 리스트로 모아야 한다면, flapMap을 쓴다. (flatMap.toSet())
    - 특별히 변환해야 할 내용이 없다면 리스트를 평평하게 펼치기만 하면된다. flatten을 쓰면 된다.
### 지연 계산
- Sequence를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다. (성능이 좋아진다...)
- 시퀀스에 대한 연산을 지연 계산하기 때문에 정말 계산을 실행하게 만들려면 최종 시퀀스의 원소를 하나씩 이터레이션하거나 최종 시퀀스를 리스트로 변환해야 한다.
#### 시퀀스 연산 실행: 중간 연산과 최종 연산
- 중간 연산은 다른 시퀀스를 반환한다. 중간 연산은 항상 지연 계산된다.
- 최종 연산은 결과를 반환한다. 최종 연산을 호출하면 연기됐던 모든 계산이 수행된다.
- 시퀀스는 자바8의 스트림과 비슷하다. (스트림의 병렬처리 기능은 제공하지 않는다. )
- `asSequence`: 컬렉션을 시퀀스로 바꾼다.
- `generateSequence`: 이전 원소를 인자로 받아 다음 원소를 계산한다. (재귀 호출 같네...)
    - ```kotlin
      val naturalNumbers = generateSequence(0){it+1}
      val numbersTo100 = naturalNumbers.takeWhile{it <= 100}
      ```
### 자바 함수영 인터페이스 활용
- 코틀린은 함수형 인터페이스를 인자로 취하는 자바 메서드를 호출할 때 람다를 넘길 수 있게 해준다.
- 정의가 들어있는 함수의 변수에 접근하지 않는 람다에 대응하는 무명 객체를 메서드를 호출할때마다 반복 사용한다.
- 람다가 주변 영역의 변수를 포획한다면 매 호출마다 같은 인스턴스를 사용할 수 없다. 컴파일러는 매번 주변 영역의 변수를 포획한 새로운 인스턴스를 생성해준다.
#### SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경 
- SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수다.
```kotlin
fun createAllDoneRunnable(): Runnable {
  return Runnable { println("All done!") }
}
```
- SAM 생성자는 그 함수형 인터페이스의 유일한 추상 메서드의 본문에 사용할 람다만을 인자로 받아서 함수형 인터페이스를 구현하는 클래스의 인스턴스를 반환한다.
- 람다에는 무명객체와 달리 인스턴스 자신을 가리키는 this가 없다.
### 수신 객체 지정 람다: with와 apply
- 수신 객체를 명시하지 않고 람다 본문 안에서 다른 객체의 메서드를 호출할 수 있게 하는 것
#### with
- with함수는 첫번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다. 인자로 받은 람다 본문에서는 this를 사용해 그 수신 객체에 접근할 수 있다.
- ```kotlin
  fun alphabet() = with(StringBuilder()) {
    for (letter in 'A' .. 'Z') {
      append(letter)
    }
    append("\nNow !")
    toString()

  }
  ```
- with가 반환하는 값은 람다 코드를 실행한 결과이다, 그 결과는 람다 식의 본문에 있는 마지막 식의 값이다.
#### apply
- 람다 결과 대신 수신 객체가 필요한 경우 apply 라이브러리 함수를 사용할 수 있다.
```kotlin
fun alphabet() = StringBuilder().apply {
  for (letter in 'A' .. 'Z') {
    append(letter)
  }
  append("!!!")
}.toString()  
```
