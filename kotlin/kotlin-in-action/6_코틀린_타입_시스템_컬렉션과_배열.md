### 컬렉션과 배열 
#### 널 가능성과 컬렉션 
- `List<Int?>` 리스트 안의 각 값이 널이 될 수 있다.
- `List<Int>?` 전체 리스트가 널이 될 수 있다.
- `filterOrNotNull`이라는 함수로 null이 아닌 값만 걸러낼 수 있다. 이 연산으로 반환된 컬렉션 타입은 null일 수 없는 타입이다. (List<Int>)
#### 읽기 전용과 변경 가능한 컬렉션 
- 코틀린에서는 컬렉션 안의 데이터에 **접근**하는 인터페이스와 컬렉션 안의 데이터를 **변경**하는 인터페이스를 분리했다는 점이다. 
- 접근: kotlin.collections.Collection
- 변경: kotlin.collections.MutableCollection
> 변경 가능한 컬렉션과 읽기 전용 컬렉션이 같은 참조객체를 가리키는 상황이 있을 수 있다. 병렬 처리 상황에서 ConcurrentModificationException이나 다른 오류가 발생할 수 있다. 따라서 읽기 전용 컬렉션이 항상 스레드 안전하지는 않다.
> 자바에는 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구분하지 않는다. 따라서 읽기 전용 컬렉션을 넘겨도 값을 수정할 수 있다.
#### 컬렉션을 플랫폼 타입으로 다루기 
- 플랫폼 타입에서 널 가능성을 다룰 때처럼 이런 경우에도 오버라이드하려는 메서드의 자바 컬렉션 타입을 어떤 코틀린 컬렉션 타입으로 표현할 지 결정해야 한다.
#### 객체의 배열과 원시 타입의 배열 
- 코틀린 배열은 타입 파라미터를 받는 클래스다. 배열의 원소 타입은 타입 파라미터에 의해 결정된다.
- `arrayOf`: 함수에 원소를 넘기면 배열을 만들 수 있다.
- `arrayOfNulls`: 함수에 정수 값을 인자로 넘기면 모든 원소가 null이고 인자로 넘긴 값과 크기가 같은 배열을 만들 수 있다. 물론 원소 타입이 널이 될 수 잇는 타입인 경우에만 이 함수를 쓸 수 있다.
- `Array 생성자`: 배열의 크기와 람다를 인자로 받아서 람다를 호출해서 각 배열 원소를 초기화해준다. arrayOf를 쓰지 않고 각 원소가 널이 아닌 배열을 만들어야 하는 경우 사용한다.
    - ```kotlin val letters = Array<String>(26) {i -> ('a'+i).toString()}```  
- 코틀린은 원시 타입의 배열을 표현하는 클래스를 제공한다. IntArray, ByteArray, charArray, BooleanArray, 이 모든 타입은 자바 원시 타입 배열인 int[], byte[], char[] 등으로 컴파일 된다.
- 박싱된 갑싱 들어있는 컬렉션이나 배열이 있다면 toIntArray 등의 변환 함수를 사용해 박싱하지 않은 값이 들어있는 배열로 변환할 수 있다.

