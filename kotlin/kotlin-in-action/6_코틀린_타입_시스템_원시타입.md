### 널 가능성 
- 코틀린을 비롯한 최신 언어에서는 null에 대한 접근 방법은 가능한 이 문제를 컴파일 시점으로 옮기는 것이다. null이 될수 있는지를 타입 시스템에 추가함으로써 예외의 가능성을 줄일 수 있다.
#### 널이 될 수 있는 타입
- 코틀린 타입 시스템은 널이 될 수 있는 타입을 명시적으로 지원한다. 널을 받을 수 있게 하려면, 타입 이름 뒤에 물음표를 적어야 한다.
- `fun strLenSafe (s: String?) = ...`
#### 타입의 의미
- 널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분하면 각 타입의 값에 대해 어떤 연산이 가능할지 명확히 이해할 수 있고, 실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있더. 따라서 그런 연산을 아예 금지시킬 수 있다.
#### 안전한 호출연산자: ?
```kotlin
fun managerName(employee: Empolyee): String? = employee.manager?.name
fun Person.countryName(): String {
  val country = this.company?.address?.country
  return if (country != null) country else "Unkown" 
}
```
#### 엘비스 연산자: ?
- 코를린은 null 대신 사용할 디폴드 값을 지정할 때 편라히게 사용할 수 있는 연산자를 제공한다. 그 연산자는 엘비스 연산자라고 한다.
- ```kotlin
  fun foo(s: String?) {
    val t: String = x ?: ""
  }
  ```
#### 안전한 캐스트: as?
- as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다. as?는 값을 대상 타입으로 변환할 수 없으면 Null을 반환한다.
- ```kotlin val otherPerson = o as? Person ?: return false```
#### 널 아님 단언: !!
- 어떤 값이든 널이 될 수 없는 타입으로 (강제로) 바꿀 수 있다. 실제 널에 대해 !!을 적용하면 NPE가 발생한다.
#### let 함수
- let 함수를 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 한꺼번에 처리할 수 있다.
- ```kotlin email?.let {email -> sendEmailTo(email)} ```
    - email 주소가 null이 아닌 경우에만 호출된다. 
- let을 쓰면 식의 결과를 저장하는 변수를 따로 만들 필요가 없다. 

#### 널이 될 수 있는 타입 확장 
- 널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다. 직접 변수에 대해 메서드를 호출해도 확장함수인 메서드가 알아서 널을 처리해준다.
- ```kotlin
  fun String?.isNullOrBlank(): Boolean = this == null || this.isBlank()
  ```
- 코틀린에서는 this도 null이 될 수 있다.
- let을 사용할 때 수신 객체가 널이 아닌지 검사하고 싶다면 안전한 호출 연산인 `?.`을 사용해야 한다.
#### 타입 파라미터의 널 가능성 
- 코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.
- 따라서 타입 파라미터 T를 클래스나 함수 안에서 타입이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입이다.
- 널이 될 수 없는 타입 상한을 지정하면 널이 될 수 있는 값을 거부하게 된다.
```kotlin
fun <T:Any> printHashCode(t:T) {
  println(t.hashCode())
}
```
### 코틀린의 원시 타입
#### 원시타입: Int, Boolean
- 코틀린은 원시 타입과 래퍼 타입을 구분하지 않으므로 항상 같은 타입을 사용한다.
- 실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 펴혼된다. 대부분의 경우 코틀린의 Int 타입은 자바 int 타입으로 컴파일된다. 컴파일이 불가능한 경우는 컬렉션과 같은 제네렉 클래스를 사용하는 경우 뿐이다. Int 타입을 컬렉션의 타입 파라미터로 넘기면 그 컬렉션에는 Int의 래퍼 타입에 해당하는 java.lang.Integer 객체가 들어간다. 
- 코틀린의 타입 중 자바 원시 타입에 해당하는 것들.
    - 정수 타입: Byte, Short, Int, Long
    - 부동소수점 수 타입: Float, Double
    - 문자 타입: Char
    - 불리언 타입: Boolean
#### 널이 될 수 있는 원시 타입: Int?, Boolean? 등 
- 코틀린에서 널이 될 수 있는 원시 타입을 사용하면, 그 타입은 자바의 **래퍼** 타입으로 컴파일된다.
- 어떤 클래스의 타입 인자로 원시 타입을 넘기면 코틀린은 그 타입에 대한 **박스(래퍼)** 타입을 사용한다.
    - JVM에서 제네릭을 구현하는 방법 때문이다. JVM은 타입 인자로 원시 타입을 허용하지 않는다. 따라서 자바나 코틀린에서 모두 제네릭 클래스는 항상 박스 타입을 사용해야 된다.
#### 숫자 변환
- 코틀린은 한 타임의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다. 결과 타입이 허용하는 숫자의 범위가 원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능하다. 직접 변환 메소드를 호출해야 한다. 
- 코틀린은 모든 원시 타입에 대한 변환 함수를 제공한다. 그런 변환 함수의 이름은 toByte(), toShort(), toChar() 등과 같다.
- 숫자 리터럴을 사용할 때는 보통 변환 함수를 호출할 필요가 없다. 42L이나 42.0f처럼 상수 뒤에 타입을 표현하는 문자를 붙이면 변환이 필요 없다. 또한 여러분이 직접 변환하지 않아도 숫자 리터럴을 **타입이 알려진** 변수에 대입하거나, 함수에게 인자로 넘기면 컴파일러가 필요한 변환을 자동으로 넣어준다.
#### Any, Any?: 최상위 타입 
- 자바에서 Object가 클래스 계층의 최상위 타입이듯 코틀린에서는 Any타입이 **모든 널이 될 수 없는 타입**의 조상 타입이다.
- 자바에서 Object는 참조 타입만 포함하지만, 코틀린의 Any는 모든 타입을 포함한다.
#### Unit 타입: 코틀린의 void
- 코틀린 Unit 타입은 자바 void와 같은 기능을 한다. 관심을 가질 만한 내용을 전혀 반환하지 않는 함수의 반환 타입으로 Unit을 쓸 수 있다.
- Unit은 모둔 기능을 갖는 일반적인 타입이며, void와 달리 Unit을 타입 인자로 쓸 수 있다.
- Unit은 **단 하나의 인스턴스만 갖는 타입**이다. 
~~~kotlin
interface Processor<T> {
  fun process(): T
}
class NoResultProcessor : Processor<Unit> {
  override fun process() { // Unit을 반환하지만 타입을 지정할 필요는 없다. 컴파일러가 묵시겆ㄱ으로 return Unit을 넣어준다.
  }
}
~~~
#### Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다. 
- Nothing 타입은 아무 값도 포함하지 않는다. 따라서 Nothing은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다. 
```kotlin
fun fail (message: String): Nothing {
  throw IllegalStateException(message)
}
val address = company.address ?: fail("No address") // null아니면 예외가 발생한다.
```
