> 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서는 관례convention이라고 부른다.
> 언어 기능을 타입에 의존하는 자바와 달리 코틀린은 관례에 의존한다. 코틀린에서 이런 관례를 채택한 이유는 기존 자바 클래스를 코틀린 언어에 적용하기 위해서다.
### 산술 연산자 오버로딩 
#### 이항 산술 연산 오버로딩
-```kotlin
  data class Point(val x:Int, val y:Int) {
    operator fun plus (other: Point): Point { // plus라는 이름의 연산자 함수를 정의한다.
        return Point(x + other.x, y + other.y) // 좌표를 성분별로 더한 새로운 점을 반환한다.
    }
  }
  ```
-```kotlin
 operator fun Point.plus(other: Point): Point {
     return Point (x + other.x, y + other.y) 
 }
 ```      
- 오버로딩 가능한 이항 산술 연산자

| 식 | 함수 이름 |
| -- | -- |
| a * b | times |
| a / b | div |
| a % b | mod (1.1부터 rem) |
| a + b | plus |
| a - b | minus |

- 직접 정의한 함수를 통해 구현하더라도 연산자 우선 순위는 언제나 표준 숫자 타입에 대한 연산자 우선 순위와 같다.
- 연산자를 정의할 때, 두 피연산자가 같은 타입일 필요는 없다. 교환법첵 성질을 지원하지는 않는다.

#### 복합 대입 연산자 오버로딩
- +=, -= 등의 연산자는 복합 대입 연산자라 불린다. compound assignment
- +=: plusAssign, -=: minusAssign, *= timesAssign
- 코틀린 표준 라이브러리는 컬렉션에 대해 2가지 접근 방법을 함께 제공한다. +와 -는 항상 새로운 컬렉션을 반환하며, +=와 -=연산자는 항상 변경 가능한 컬렉션에 작용해 메모리에 있는 개체 상태를 변화시킨다. 
- plus와 plussAssign을 동시에 정의하지 말라. 클래스가 앞에서 본 Point처럼 변경 불가능하다면 (plus만) 새로운 값을 반환하는 연산만을 추가해야 한다. 
#### 단항 연산자 오버로딩
- 오버로딩 가능한 단항 한술 연산자
| 식 | 함수 이름 |
| -- | -- |
| +a | unaryPlus |
| -a | unaryMinus |
| !a | not |  
| ++a, a++ | inc |
| --a, a-- | dec |
  

  
