### 제네렉 타입 파라미터
- 제네릭스를 사용하면 받는 타입을 정의할 수 있다. 제네릭스 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 타입 인자로 치환해야 한다.
- 코틀린 컴파일러는 타입 인자도 추론할 수 있다.
- ```kotlin
  val authors = listOf("Dmitry", "Svetlana")
  val readers: MutableList<String> = mutableListOf()
  val readers = mutableListOf<String>()
  ```
#### 제네릭 함수와 프로퍼티 
- 제네릭 함수 선언
    - ```kotlin
      fun <T> List<T>.slice(indices: IntRange): List<T>
      ```
- 일반 프로퍼티(클래스 내부필드)는 타입 파라미터를 가질 수 없다. 확장 프로퍼티에는 제네릭스를 사용할 수 있다.
    - ```kotlin
      val <T> List<T>.penultimate: T
          get() = this[size-2]
      ```
#### 제네릭 클래스 선언 
- ```kotlin
  interface List<T> {
    operator fun get (index: Int): T 
  }
  ```
#### 파라미터 제약 
```kotlin
fun <T: Number> List<T>.sum(): T
```
#### 타입 파라미터를 널이 될 수 없는 타입으로 한정하기
- 제네릭 클래스나 함수를 정의하고, 그 타입을 인스턴스화할 때는 널이 될 수 있는 타입을 포함하는 어떤 타입으로 타입 인자를 지정해도 타입 파라미터를 치환할 수 있다. 아무런 상한을 정하지 않은 타입 파라미터는 결과적으로 Any?를 상환으로 정한 파라미터와 같다.
- `<T:Any>`라는 T 타입이 항상 널이 될 수 없는 타입이 되게 보장한다.

### 실행 시 제네릭의 동작: 소거 타입 파라미터와 실체화된 타입 파라미터
- 자바와 마찬가지로 코틀린의 제네릭 타입 인자 정보는 런타임에 지워진다.
- 코틀린에서는 타입 인자를 명시하지 않고, 제네릭 타입을 사용할 수 없다.
    - ```kotlin
      if (value is List<*>) {...}
      ```
- as나 as? 캐스팅에도 여전히 제네릭 타입을 사용할 수 있다. 하지만 기저 클래스는 같지만 타입 인자가 다른 타입으로 캐스팅해도 여전히 캐스팅에 성공한다는 점을 조심해야 한다.
- is 검사는 수행할 수 있다. `if( c is List<Int>)`      
- 코틀린 제레릭 타입이 타입 인자 정보를 실행 시점에 지워진다. **인라인 함수**의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.
- 타입 파라미터를 Reified로 지정하면 value가 타입 T의 인스턴스인지 확인할 수 있다.
- ```kotlin
  inline fun <reified T> isA(value: Any) = value is T
  println(isA<String>("abc")
  ```

## 변성: 제네릭과 하위타입 
- 변성variance는 List<String>과 List<Any>와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.
- 어떤 함수가 리스트의 원소를 추가하거나, 변경한다면 타입 불일치가 생길 수 있어서, List<Any> 대신 List<String>을 넘길 수 없다. 하지만 원소 추가나 변경이 없는 경우에는 List<String>을 List<Any> 대신 넘겨도 안전하다.
- 타입과 클래스
    - 클래스는 개념이고 타입은 선언인가..
    - 클래스 이름을 타입으로 쓸 수 있다. 그리고 타입은 ?널이 될 수 있는 타입과, 아닌 타입으로 나눠진다.
    - 타입A(널이 될 수 없는)은 타입 A?(널이 될 수 있는)의 하위 타입이다.
- 공변과 무공변
  - 공변적 covariant: 하위 타입 관계가 성립하는 경우
  - 무공변 invariant: 하위 타입 관계가 성립하지 않는 경우 
  - 자바에서는 제네릭 타입을 사용할 때, 상속관계가 적용되지 않는다. (무공변이다.)
  - **out 키워드**
    - out을 사용하면 공변성을 정의하는데 사용된다.
    - 클래스 타입 파라미터 T앞에 out 키워드를 붙이면 클래스 안에서 T를 사용하는 메서드가 아웃 위치에서만 T를 사용하게 허용하고 인 위치에서는 T를 사용하지 못하게 막는다.
    - ```kotlin
      class Herd<T:Animal>{} // 무공변
      class Herd<out T:Animal>{} //공변
      ```
- 반공변성
  - 타입B가 타입A의 서브타입일때, List<A>가 List<B>의 서브타입인 것.
  - in 키워드
    - 반공변성을 정의하는데 사용된다.
    - 클래스 타입 파라미터 T 앞에 in키워드를 붙이면, T가 in 위치에서만 (소비만 된다) 사용된다는 뜻이다.
    - 더 구체적인 타입을 일반적인 타입으로 대체할 수 있기 때문에 관계가 역전된다. (in에선 그렇구나. animal로 선언하면 dog가 들어오는데, dog로 선언하면 animal이 못들어오니까)       
- 사용 지점 변성
  - 선언 지점 변성: declaration site variance 클래스를 사용하는 모든 지점에 변성 지정자가 영향을 끼친다. (클래스 선언부) (코틀린)
  - 사용 지점 변성: use site variance 타입 파라미터를 사용할 때마다, 변성일 명시해야 한다. (메소드 선언부) (자바)
      - 코틀린에서도 사용 지점 변성을 사용할 수 있다.
      
