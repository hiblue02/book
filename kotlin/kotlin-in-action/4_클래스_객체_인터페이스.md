### 클래스 계층 정의 
#### 코틀린 인터페이스 
- 자바에서는 extends와 implements 키워드를 사용하지만, 코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.
- 자바와 마찬가지로 클래스는 인터페이스를 원하는 만큼 개수 제한 없이 마음대로 구현할 수 있지만, 클래스는 오직 하나만 확장할 수 있다. 
```kotlin
class Button: Clicable{
  override fun click() = println("I was clicked")
}
```
- 코틀린에서는 override 변경자를 꼭 사용해야 한다.
- 인터페이스에 같은 시그니처의 메서드가 있다면, (메서드가 이미 정의되어있다 하더라도) 컴파일 오류가 발생한다. 구현을 대체할 오버라이딩 메서드를 정의해야 한다. 
```kotlin
class Buttion: Clickable, Focusable {
  override fun click() = println("I was clicked")
  override fun showOff() {
    super<Clickable>.showOff() // 어떤 상위 타입의 메서드를 호출할 지 지정할 수 있다.
    super<Focusable>.showOff()
  }
}
```
#### open, final, abstract 변경자 : 기본적으로 final 
- 자바의 클래스와 메서드는 기본적으로 상속에 대해 열려있지만, 코틀린의 클래스와 메서드는 기본적으로 final이다.
- 어떤 클래스의 상속을 허용하려면, 클래스 앞에 open 변경자를 붙여야 한다. 그와 더불어 오버라이드를 허용하고 싶은 메서드나 프로퍼티 앞에서도 open 변경자를 붙어야 한다.
```kotlin
open class RichButton: Clickable{
  fun disable {} // final이다. 하위 클래스가 오버라이드 할 수 없다.
  open fun animate() {} // 이 함수는 열려 있다. 하위 클래스에서 이 메서드를 오버라이드 해도 된다.
  override fun click() {} // 이 함수는 (상위 클래스에서 선언된) 열려있는 메서드를 오버라이드 한다. 오버라이드한 메서드는 기본적으로 열려있다.
  final override fun push() {} //  이 함수는 하위 클래스에서 오버라이드 하지 못한다. final
}
```
> 클래스를 final로 선언한다는 것은 다양한 경우에 스마트 캐스트가 가능하다는 장점이 있다. 스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용 가능하다.
> 프로퍼티가 final이 아니라면 다른 클래스가 상속하면서 커스텀 접근자를 정의함으로써 스마트 캐스트의 요구사항을 깰 수 있다. 

- 클래스 내의 상속변경자의 의미
|변경자|변강자가 붙은 멤버는...|설명|
|--|--|--|
| final | 오버라이드 할 수 없음 | 클래스 멤버의 기본 변경자다.|
| open | 오버라이드 할 수 있음 | 반드시 open을 명시해야 오버라이드 할 수 있다. |
| abstract | 반드시 오버라이드 해야 함 | 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현이 있으면 안된다. |
| override | 상위 클래스나 상위 인스턴스의 멤버를 오버라이드 하는 중 | 오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면, final을 명시해야 한다.|

#### 가시성 변경자: 기본은 public
|변경자| 클래스 멤버 | 최상위 선언|
|--|--|--|
| public(기본 가시성임) | 모든 곳에서 볼 수 있다. | 모든 곳에서 볼 수 있다. |
| internal | 같은 모듈 안에서만 볼 수 있다. | 같은 모듈 안에서만 볼 수 있다. |
| protected | 하위 클래스 안에서만 볼 수 있다. | 최상위 선언에 적용할 수 없음 | 
| private | 같은 클래스 안에서만 볼 수 있다. | 같은 파일 안에서만 볼 수 있다. |
- 자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린에서는 그렇지 않다는 점에서 자바와 코틀린의 protected가 다르다는 사실에 유의하자.
- 코틀린에서는 외부 클래스가 내부 클래스나 중첩 클랫의 private 멤버에 접근할 수 없다.
#### 내부 클래스와 중첩 클래스: 기본은 중첩 클래스 
- 자바 중첩 클래스와 내부 클래스 : https://madeprogame.tistory.com/72
- 코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다.
- 코틀린 중첩 클래스는 기본적으로 자바의 static 중첩 클래스와 같다. 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들고 싶다면 Inner 변경자를 붙여야 한다. 
| 클래스 B안에 정의된 클래스 A | 자바에서는 | 코틀린에서는 |
| -- | -- | -- |
| 중첩 클래스 (바깥쪽 클래스에 대한 참조를 저장하지 않음) | static class A | class A |
| 내부 클래스 (바깥쪽 클래스에 대한 참조를 저장함) | class A | inner class A | 
#### 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한 
- 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.

### 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언 
- 코틀린은 주 생성자와 부 생성자를 구분한다. 또한 코틀린에서는 초기화 블록을 통해 초기화 로직을 추가할 수 있다. 
    - 주 생성자: 클래스를 초기화할 때 사용하는 간략한 생성자로 클래스 본문 밖에서 정의한다.
    - 부 생성자: 클래스 본문 안에서 정의한다.
#### 클래스 초기화: 주 생성자와 초기화 블록 
- 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 주 생성자라고 부른다. 
```kotlin
class User(val nickname: String)
```
```kotlin
class User consturctor(_nickname: String) { // 생성자 블록
   val nickname: String
  init { // 초기화 블록
    nickname = _nickname
    }
}
```
- constructor는 주 생성자나 부 생성자를 정의할 때 사용한다. init 키워드는 초기화 블록을 시작한다.
- 클래스의 인스턴스를 만들려면 new 키워드 없이 생성자를 직접 호출하면 된다.
- 모든 생성자에 디폴드 값을 지정하면 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어준다.
#### 부 생성자: 상위 클래스를 다른 방식으로 초기화 
- 자바에서 오버로드한 생성자가 필요한 상황 중 상당수는 코틀린의 디폴트 파라미터 값과 이름 붙인 인자 문법을 사용해 해결할 수 있다.
- 인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여럿 만들지 말라. 대신 파라미터의 디폴트 값을 생성자 시그니처에 직접 명시하라.
```kotlin
open class View {
  constructor(ctx: Context) {
  }
}
```
#### 인터페이스에 선언된 프로퍼티 구현 
- 코틀린에서는 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다.
- 인터페이스에 게터와 세터가 있는 프로퍼티를 선언할 수도 있다. 물론 그런 게터와 세터는 뒷받침하는 필드를 참조할 수 없다.
- 인터페이스에 선언된 프로퍼티와 달리 클래스에 구현된 프로퍼티는 뒷받침하는 필드를 원하는 대로 사용할 수 있다. 
```kotlin
class PrivateUser(override val nickname: String): User // 주 생성자에 있는 프로퍼티
class SubscribingUser(val email: String): User {
  override val nickname: String
  get() = email.substringBefore('@') // 커스텀 게터 
}
class FaceBookUser(val accountId: String): User { 
  override val nickname= getFacebookName(accountId) // 프로퍼티 초기화 식
}
```
#### 게터와 세터에서 뒷받침하는 필드에 접근 
- 코틀린에서 프로퍼티 값을 바꿀 때는 `user.address = "new value"`처럼 필드 설정 구문을 사용한다. 이 구문은 내부적으로는 세터를 호출한다.
- 접근자의 본문에서는 field라는 특별한 식별자를 통해 뒷받침하는 필드에 접근할 수 있다. 게터에서는 field 값을 읽을 수만 있고, 세터에서는 field 값을 읽거나 쓸 수 있다.
```kotlin
class User(val name:String) {
  var address: String = "unspecified"
  set(value: String) {
     println("$field -> $value")
     field = value
  }
}
```
### 컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임 
#### 데이터 클래스: 모든 클래스가 정의해야 하는 메서드 자동 생성
- 어떤 클래스가 데이터를 저장하는 역할만을 수행한다면 toString, equals, hashCode를 반드시 오버라이드해야 한다. 코틀린에서 **data** 변경자가 붙은 클래스를 선언하면 컴파일러가 필요한 메서드를 자동으로 만들어준다.
- **copy()**: 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해주는 편의 메서드
- **by** 클래스 위임
    - 자바의 데코레이터 패턴: 상속을 허용하지 않는 클래스를 데코레이터 내부 필드로 유지
    - 코틀린에선 인터페이스를 구현할 때 by 키워드를 통해 그 인터페이스 대한 구현을 다른 객체에 위임 중이라는 사실을 명시할 수 있다.
    - ```kotlin
      class DelegatingCollection<T> (
        innerList: Collection<T> = ArrayList<T>()
      ) : Collection<T> by innerList{}
      ```
### object: 클래스 선언과 인스턴스 생성 
- 코틀린에서의 object 키워드
    - 객체 선언 object declaration은 싱글턴을 정의하는 방법 중 하나다.
    - 동반 객체 companion object는 인스턴스 메서드는 아니지만 어떤 클래스와 관련 있는 메서드와 팩터리 메서드를 담을 때 쓰인다. 동반 객체 메서드에 접근할 때는 동반 객체가 포함된 클래스의 이름을 사용할 수 있다.
    - 객체 식은 자바의 무명 내부 클래스anonymous inner class 대신 쓰인다.
#### 객체 선언: 싱글톤 쉽게 만들기 
```kotlin
object Payroll {
  val allEmployees = arrayListOf<Person>()
  fun calculateSalary() {
    for ~ ~
  }
}
```
- 코틀린의 객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다.
- 생성자는(주 생성자와 부 생성자 모두) 객체 선언에 쓸 수 없다. 일반 클래스 인스턴스와 돨리 싱글턴 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어진다. 따라서 객체 선언에는 생성자 정의가 필요 없다.
#### 동반 객체: 팩토리 메서드와 정적 멤버가 들어갈 장소 
- 클래스 내부 정보에 접근해야 하는 함수가 필요할 때는 클래스에 중첩된 객체 선언의 멤버 함수로 정의해야 한다. 그런 함수의 대표적인 예로 팩토리 메서드를 들 수 있다.
- 클래스 안에 정의된 객체 중 하나에 `companion` 선언을 붙이면 동반 객체를 만들 수 있다.
```kotlin
class A {
  companion object {
    fun bar() {
      println("Companion object called")
    }
  }
}
```
- 코틀린의 동반 객체는 일반 객체와 비슷한 방식으로, 클래스에 정의된 인스턴스를 가리키는 정적 필드로 컴파일 된다. 동반 객체에 이름을 붙이지 않았다면, 잡 쪽에서 Companion이라는 이름으로 그 참조에 접근할 수 있다.
#### 객체 식: 무명 내부 클래스를 다른 방식으로 작성 
- 객체 식은 클래스를 정의하고 그 클래스에 속한 인스턴스를 생성하지만, 그 클래스나 인스턴스에 이름을 붙이지는 않는다. 이런 경우 보통 함수를 호출하면서 인자로 무명 객체를 넘기기 때문에 클래스와 인스턴스 모두 이름이 필요하지 않다.
- 객체 선언과 달리 무명 객체는 싱글턴이 아니다. 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다.
- 자바의 무명 클래스와 같이 객체 식 안의 코드은 그 식이 포함된 함수의 변수에 접근할 수 있다. 하지만 자바와 달리 final이 아닌 변수도 객체 식 안에서 사용할 수 있다.
- 객체 식은 무명 객체 안에서 여러 메서드를 오버라이드 해야 하는 경우에 훨씬 더 유용하다. 메서드가 하나 뿐인 인터페이스를 구현해야 한다면 코틀린의 SAM 지원을 활요하는 편이 낫다. (함수형 인터페이스 구현과 람다.. 겠군)
